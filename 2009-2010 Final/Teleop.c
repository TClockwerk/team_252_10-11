#pragma config(Hubs,  S3, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     rfid,                sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     ,                    sensorHiTechnicTouchMux)
#pragma config(Motor,  motorA,          a,             tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          b,             tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S3_C1_1,     motorD,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     motorE,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C2_1,     motorF,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C2_2,     motorG,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C3_1,     motorH,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C4_1,     motorJ,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C4_2,     motorK,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int nMask;//used for touch mux
bool touchFS;//touch sensor for swinger
bool rightH;//right helicopter touch sensor
bool leftH;//left helicopter touch sensor
/*
VERSION 0.9 ALL BUGS FIXED UNTESTED
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													 Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"	 //Include file to "handle" the Bluetooth messages.
#include "Teleop menu.h"//header
int touchFSt;//amount of touches
#pragma systemFile
#define diagDisplay 1//use our diagnostic display
bool initDone = false;//are we initialized
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()//initialzation procedure
{
	bMotorFlippedMode[motorG] = true;//flip motor
	bMotorFlippedMode[motorK] = true;//flip motor
	bMotorFlippedMode[motorD] = true;//flip motor
	bMotorFlippedMode[motorB] = true;//flip motor
	RFIDInit(S1);//initialized RFID
	if(diagDisplay){//if using our diag display
		disableDiagnosticsDisplay();//disable the FTC diag display
		menu_init();//initialize our menu
	}
	initDone = true;//we have initialized
	return;
}

string mtrName = "";//the name of the motor to debug -- global
void debugMotor(int *mtr){//pointer to the motor variable we are debugging
	if(screenText[0] != mtrName + " = 0" && mtr == 0){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshhold
		NSLog(mtrName + " = 0");//notify that it is stopped
		}else if(screenText[0] == mtrName + " = 0" && mtr != 0){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshhold
		NSLog(mtrName + " is now running");//notify that it just started running
		}else if(screenText != mtrName + " = 25" && mtr >= 25 && mtr < 50){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = 25");//notify that we have hit 25
		}else if(screenText[0] != mtrName + " = 50" && mtr >=50 && mtr <75){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = 50");//notify that we have hit 50
		}else if(screenText[0] != mtrName + " = 75" && mtr >=75 && mtr <99){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = 75");//notify that we have hit 75
		}else if(screenText[0] != mtrName + " = 100" && mtr>=99){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = 100");//notify that we have hit 100
		}else if(screenText != mtrName + " = -25" && mtr <= -25 && mtr > -50){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = -25");//notify that we have hit -25
		}else if(screenText[0] != mtrName + " = -50" && mtr <=-50 && mtr >-75){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = -50");//notify that we have hit -50
		}else if(screenText[0] != mtrName + " = -75" && mtr <=-75 && mtr >-99){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = -75");//notify that we have hit -75
		}else if(screenText[0] != mtrName + " = -100" && mtr<=-99){//if the last bit of logged text is not a debug line that we would be about to write and we are over the threshold
		NSLog(mtrName + " = -100");//notify that we have hit -100
	}
}
void updateMotors(){
  //set motors to associated variables
	motor[motorA] = H;
	motor[motorD] = B;
	motor[motorE] = S;
	motor[motorF] = LF;
	motor[motorG] = RF;
	motor[motorH] = LE;
	motor[motorI] = RE;
	motor[motorJ] = LR;
	motor[motorK] = RR;
	if(LHR){
	  LHS = 100;
  }else if(LH  == 1){
	  LHS = -100;
	}else if(LH == 0){
	  LHS = 0;
	}
	motor[motorB] = LHS;
	//mtrName = "S";
	//debugMotor(S);
}

void setAll(int speed){//set all motors to passed speed
LR = speed;
LF = speed;
LE = speed;
RE = speed;
RF = speed;
RR = speed;
S = speed;
H = speed;
B = speed;
updateMotors();
}
/*
void TestAll(){
PlayImmediateTone(50,500);
wait10Msec(500);
nxtDisplayCenteredBigTextLine(3,"Forward");
setAll(50);
wait1Msec(2000);
nxtDisplayCenteredBigTextLine(3,"Reverse");
setAll(-50);
wait1Msec(2000);
setAll(0);
}*/
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																				 Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//	 1. Loop forever repeating the following actions:
//	 2. Get the latest game controller / joystick settings that have been received from the PC.
//	 3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//			simple action:
//			*	 Joystick values are usually directly translated into power levels for a motor or
//				 position of a servo.
//			*	 Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//				 position.
//	 4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task rotateH(){//rotate hopper one rotation
  if(initDone){//if we are initialized
    if(current_function == 4){//if we are on hopper screen
      joyOverRide = true;//override setting to 0 of hopper
    }
    while(nMotorEncoder[motorA] < 388){//while are at less than 388 encoder units
      if(current_function == 4){//if we are on hopper screen
        joyOverRide = true;//override setting to 0 of hopper
      }
      H = 100;//set hopper to 100
      }
      time1[T3] = 0;//set timer to 0
      nMotorEncoder[motorA] = 0;//reset motor encoder
  }
}
task HL(){//helocopter left
  time1[T2] = 0;//set time 2 to 0
  if(initDone){//if we are initalized
    while(!leftH && time1[T2] < 2000){//while we have not hit the left helicopter sensor and have not timedout
      B = 100;//set helicopter to 100
    }
    B = 0;//stop helicopter
  }
}

task HR(){//helicopter right
  time1[T2] = 0;//set time 2 to 0
  if(initDone){//if we are initialized
    while(!rightH && time1[T2] < 2000){//while we have not hit the left helicopter sensor and have not timedout
      B = -100;//set helicopter to -100
    }
    B = 0;//stop helicopter
  }
}
task SFO(){//spin swinger around once
  if(initDone){//if we are initialzed
    while(!touchFS){//while we havent hit touch sensor
      S = 100;//run swinger forward at 100
    }
    S = 0;//stop swinger
  }

}

task main()
{

	initializeRobot();//initialize robot
	waitForStart();		// wait for start of tele-op phase

	while (true)
	{
	  nMask = SensorValue[S4];//get raw value of touchmux
	  if(nMask & 0x01){//get swinger touch sensor bool
  	  touchFS = true;//set var for touch snsor for swinger to true
  	  NSLog("b1");//log the event
  	}else{
  	  touchFS = false;//set var for touch sensor swinging to false
  	}
  	if(nMask & 0x04){//get right helicopter touch sensor as bool
  	  rightH = true;//set var for touch sensor right helcopter to true
  	  NSLog("b3");//log the event
  	}else{
  	  rightH = false;//set var for touch sensor right helcopter to false
  	}
  	if(nMask & 0x02){//get left helicopter touch sensor as bool
  	  leftH = true;//set var for touch sensor left helcopter to true
  	  NSLog("b2");//log it
  	}else{
  	  leftH = false;//set var for touch sensor left helcopter to false
  	}
	  /*if(joystick.joy1_TopHat == 0 || joystick.joy2_TopHat == 0 && time1[T2] >= 250){
	    if(LHO < 20){
	      LHO = 20;
	    }else if(LHO < 100){
	      LHO++;
	    }
	    time1[T2] = 0;
	  }
	  if(joystick.joy1_TopHat == 4 || joystick.joy2_TopHat == 4 && time1[T2] >= 250){
	    if(LHO > -100){
	      LHO--;
	    }
	  }

	  LE = LHO;
	  RE = LHO;*/
	  if(joy1Btn(5) || joy2Btn(5)){//if button 5
	    LHO = 0;//stop elavators
	  }
	  if(joystick.joy1_TopHat == 0 || joystick.joy2_TopHat == 0){//if pressing up on directional pad
	    if(LHO > -20 && LHO < 20){//if we are between -20 and 20 for speed of elavators
	      LHO = 20;//set the speed to 20
	    }else if(time1[T4] >= 100 && LHO < 100){//if we are above 20 or below -20 and it has been 100 ms since last speed increase
	      LHO++;//increase speed by 1
	      time1[T4] = 0;//reset timer
	    }

	  }
	  if(joystick.joy1_TopHat == 4 || joystick.joy2_TopHat == 4){//if pressing down on dpad
	    if(LHO > -20 && LHO < 20){//if we are between -20 and 20
	      LHO = -20;//set speed to -20
	    }else if(time1[T4] >= 100 && LHO > -100){ //if we are outside of 20 to -20 and it has been 100 ms since last speed decrease
	      LHO--; //decrease speed
	      time1[T4] = 0;//reset timer
	    }

	  }
		getJoystickSettings(joystick);
    if(joy1Btn(8)){//if we are pressing button 8
      if(abs(joystick.joy1_y1) >= 10){//if we are more than 10 either way in the y direction on left joystick on pad 1
        LE = joystick.joy1_y1*100/127;//set left elavator to left joystick percent on pad 1
      }
      if(abs(joystick.joy1_y2) >= 10){//if we are more than 10 either way in the y direction on right joystick on pad 1
        RE = joystick.joy1_y2*100/127;//set left elavator to right joystick percent on pad 1
      }
    }else if(abs(joystick.joy2_y1) >= 10 || abs(joystick.joy2_y2) >= 10 && !joy2Btn(8) && !joy2Btn(7)){//if above threshold and not pressing button 7 or 8 on pad 2
      if(abs(joystick.joy2_y1) >= 10 && !joy2Btn(8) && !joy2Btn(7)){//if left joystick on pad 2 above threshold and button 7 or 8 are not pressed
        LE = joystick.joy2_y1*100/127;//set left elavator to left joystick on joy pad 2
      }
      if(abs(joystick.joy2_y2) >= 10 && !joy2Btn(8) && !joy2Btn(7)){//if right joystick on pad 2 above threshold and button 7 or 8 are not pressed
        RE = joystick.joy2_y2*100/127;//set right elavator to the right joystick on joypad 2
      }
    }else if(LHO != 0){//if universal elavator setting is not 0
      LE = LHO;//set left elavator to universal elavator
      RE = LHO;//set right elavator to universal elavator
    }else{
      LE = 0;//set left elavator to 0
      RE = 0;//set right elavator to 0
    }
    if((!joy1Btn(8) && abs(joystick.joy1_y1) <= 10) && abs(joystick.joy2_y1) <= 10 && LHO == 0){//if not pressing button 8 on joy 1 and joy 1 left joystick is less than 10 and the left joystick on joy 2 is less than 10 and universal is not set
      LE = 0;//stop the left elevator
    }
    if((!joy1Btn(8) && abs(joystick.joy1_y2) <= 10) && abs(joystick.joy2_y2) <= 10 && LHO == 0){//if not pressing button 8 on joy 1 and joy 1 right joystick is less than 10 and the right joystick on joy 2 is less than 10 and universal is not set
      RE = 0;//stop right elavator
    }

		if(abs(joystick.joy1_y1) >= 10 && !joy1Btn(7) && !joy1Btn(8)){//if left joystick on joypad 1 if 10 or more units from center and we are not pressing 7 or 8 on joy 1
			if(current_function == 2) {//if we are looking at drive motors on menu
				joyOverRide = true;//override menu stop motors
			}
			LF = joystick.joy1_y1*100/127;//set left front to percent of left joystick pad 1
			LR = joystick.joy1_y1*100/127;//set left rear to percent of left joystick
		}else if(abs(joystick.joy2_y1) >= 10 && joy2Btn(8)){//or if the absolute val of left joystick of joy pad 2
		  if(current_function == 2){//if we are looking at drive motors
			  joyOverRide = true;//keep menu code from stopping motors
		  }
			LF = joystick.joy2_y1*100/127;//set left front to percent of left joystick pad 2
			LR = joystick.joy2_y1*100/127;//set left rear to percent of left joystick pad 2
		}else{//or if we arent running them at all
			LF = 0;//stop left front
			LR = 0;//stop left rear
		}
		if(abs(joystick.joy1_y2) >= 10 && !joy1Btn(7) && !joy1Btn(8)){//if absolute value of right joystick pad 1 is greater than to and we are not pressing 7 or 8 on joy pad 1
			if(current_function == 2){//if we are viewing drive motors
				joyOverRide = true;//keep menu code from stopping drive mototrs
			}
			RF = joystick.joy1_y2*100/127;//set right front to right joystick joy pad 1
			RR = joystick.joy1_y2*100/127;//set right rear to right joystick joy pad 1
		}else if(abs(joystick.joy2_y2) >= 10 && joy2Btn(8)){//or if right joystick on joypad to is over threshold and button 8 is pressed on joypad 2
			if(current_function == 2){//if we are viewing drive motors
				joyOverRide = true;//override the stopping of motors by menu code
			}
			RF = joystick.joy2_y2*100/127;//set the right front to right joystick joy pad 2
			RR = joystick.joy2_y2*100/127;//set the right rear to right joystick joy pad 2
		}else{//if nothing is setting the motors
			RF = 0;//stop right front
			RR = 0;//stop right rear
		}
		/*if(joy1Btn(8)){
			if(abs(joystick.joy1_y1) >= 10){
			  if(current_function == 3){
			    joyOverRide = true;
			  }
				LE = joystick.joy1_y1*100/127;
			}else if (LHO != 0){
				LE = 0;
			}
			if(abs(joystick.joy1_y2) >= 10){
				RE = joystick.joy1_y2*100/127;
			}else if(LHO != 0){
			  RE = 0;
			}
		}else if(!joy2Btn(7) && !joy2Btn(8)){
		  if(abs(joystick.joy2_y1) >= 10){
			  LE = joystick.joy2_y1*100/127;
			}else if(LHO != 0){
			  LE = 0;
		  }
		  if(abs(joystick.joy2_y2) >= 10){
			  RE = joystick.joy2_y2*100/127;
			}else if(LHO != 0){
			  RE = 0;
		  }
		}*/

		if(joy1Btn(7)){//if pressing button 7 on joystick 1
		 if(abs(joystick.joy1_y1) >= 10){//if the left joystick on joy pad 1 is above threshold
		  S = joystick.joy1_y1*100/127;//set the swinger to percent on left joystick joy pad 1

		 }else{//if not above threshold
			S = 0;//stop swinger
		 }
		 if(abs(joystick.joy1_y2) >= 10){//if right joystick joy pad 1 above threshold
			  H = joystick.joy1_y2*100/127;//set hopper to right joystick pad 2
		  }else{//if we are not
				H = 0;//then stop hopper
			}
		}
		if(joy2Btn(7)){//if we are pressing 7 on joy pad 2
		  //NSLog("joy2btn7");
			if(abs(joystick.joy2_y1) >= 10){//if left joystick on joy pad 2 is above threshold
				S = joystick.joy2_y1*100/127;//set swinger to left joystick joy pad 2 percent
			}else{//if we arent above threshold
				S = 0;//stop swinger
			}
			if(abs(joystick.joy2_y2) >= 10){//if the absolute value of the right joystick of joy pad 2 is above threshold
			  //NSLog("Hopper y2");
			  H = joystick.joy2_y2*100/127;//set hopper to precent of right joystick of joy pad 2
		  }else{//if we are not above threshold for Hopper
		    //NSLog("Hopper nulled");
				H = 0;//stop hopper
			}
		}
		if(joy1Btn(6) || joy2Btn(6) && time1[T3] >= 1000){//if we press button 6 on either pad and it has been 1000ms since last rotation
			StartTask(rotateH);//rotate the hopper once
		}
		if(!joy1Btn(7) && !joy2Btn(7)){//if we are not pressing button 7 on either pad stop the Hopper and Swinger
			H = 0;
			S = 0;
		}
		if(joystick.joy1_TopHat == 6 || joystick.joy2_TopHat == 6){ //if pressing right on the dpad of either joy pad
		  if(current_function == 7){//if on helicopter menu
		    joyOverRide = true;//keep menu code from stopping helicopter
		  }

			StartTask(HR);//spin helicopter to the right
		}else if(joystick.joy1_TopHat == 2 || joystick.joy2_TopHat == 2){//if pressing left on dpad on either joypad
		  if(current_function == 7){//if on helicopter menu
		    joyOverRide = true;//keep menu code from stopping helicopter
		  }
			StartTask(HL);//spin helicopter left
		}else{//if we are not spinning the helicopter
			B = 0;//stop helicopter
		}
		if(joy1Btn(3) || joy2Btn(3) && time1[T1] >= 500){//if pressing 3 on either controller and it has been 500ms since we last did
		//toggle LH (elavator helper)
		  if(LH == 0){
		    LH = 1;
		  }else if(LH == 1){
		    LH = 0;
		  }
		  time1[T1] = 0;//restart T1
		}
		if(joy1Btn(2) || joy2Btn(2)){//if pressing 2 on either controller
		  //reverse elavator helper
		  LHR = true;
		}else{
		  LHR = false;//run elavator helper forward
		}
		if(joy1Btn(4) || joy2Btn(4)){//if pressing 4 on either joypad
		  StartTask(SFO);//swing swinger once
		}
		if(joy1Btn(1) || joy2Btn(1)){//if press 1 on either joypad
		  StopAllTasks();//quit application
		}
		if(joy1Btn(10) || joy2Btn(10)){//if pressing 10 on either joypad
		  setAll(0);//set all motor vars to 0
		  LHR = false;//dont reverse helper
		  LH = 0;//stop elavator helper
		  LHO = 0;//stop elavators
		}
		/*if(joy1Btn(9) || joy2Btn(9)){
		  nMotorEncoder[motorA] = 0;
		  nMotorEncoder[motorB] = 0;
		  nMotorEncoder[motorD] = 0;
		  nMotorEncoder[motorE] = 0;
		  nMotorEncoder[motorF] = 0;
		  nMotorEncoder[motorG] = 0;
		  nMotorEncoder[motorH] = 0;
		  nMotorEncoder[motorI] = 0;
		  nMotorEncoder[motorJ] = 0;
		  nMotorEncoder[motorK] = 0;
		}*/
		while(joy1Btn(7) &&  joy1Btn(8)){//while pressing 7 and 8 on joy pad 1
		  getJoystickSettings(joystick);//hang and read joysticks
		}
    if(LHO != 0 && (!joy2Btn(7) && !joy2Btn(8) && (joy1Btn(8) && abs(joystick.joy1_y1) < 10)) && !joy1Btn(8) || (joy1Btn(8) && abs(joystick.joy1_y1) < 10)){//if
      LE = 0;
    }
    if(LHO != 0 && (!joy2Btn(7) && !joy2Btn(8) && (joy1Btn(8) && abs(joystick.joy1_y2) < 10)) && !joy1Btn(8) || (joy1Btn(8) && abs(joystick.joy1_y2) < 10)){
      RE = 0;
    }
    if(!joy1Btn(7) && !joy2Btn(7)){
      S = 0;
    }
    if(joy1Btn(2) || joy2Btn(2)){

      S = S/3.5;
      //NSLog(S);
    }

		/*if(joy2Btn(8) ||abs(joystick.joy2_y1) >=! 10 && !joy1Btn(8)){
		  LE = LHO;
		}
		if(joy2Btn(8) || abs(joystick.joy2_y2) >=! 10 && !joy1Btn(8)){
		  RE = LHO;
		}*/
		updateMotors();
		if(diagDisplay){
			menu_main();
		}
		joyOverRide = false;
	}
}
