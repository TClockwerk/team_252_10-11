#pragma config(Hubs,  S3, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     rfid,                sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     ,                    sensorHiTechnicTouchMux)
#pragma config(Motor,  mtr_S3_C1_1,     motorD,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     motorE,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C2_1,     motorF,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C2_2,     motorG,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C3_1,     motorH,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S3_C4_1,     motorJ,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S3_C4_2,     motorK,        tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//has touch sensor for swinger been hit
bool touchFS = false;
//has right Helicopter touch been hit
bool rightH = false;
//has left Helicopter touch been hit
bool leftH = false;
//are we initialized
bool initDone = false;
//are the elavators running
bool runningElavators = false;
//is RFID listening
bool RFIDListen = true;
//default alliance
string alliance = "red";
//default position in relation to our coloreed tube
string pos = "close";
//which tube to aim for
string autoMode = "close";
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "auto.h" //defenitions
#include "RobotCode.c" //RFID
void updateMotors(){ //turn vars into the actual motor changes
	motor[motorA] = H;
	motor[motorD] = B;
	motor[motorE] = S;
	motor[motorF] = LF;
	motor[motorG] = RF;
	motor[motorH] = LE;
	motor[motorI] = RE;
	motor[motorJ] = LR;
	motor[motorK] = RR;
	if(LHR){//interpret LHR (hopper) into speeds
	  LHS = 100;
  }else if(LH  == 1){
	  LHS = -100;
	}else if(LH == 0){
	  LHS = 0;
	}
	motor[motorB] = LHS;
	//mtrName = "S";
	//debugMotor(S);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  //set correct reversals
  bMotorFlippedMode[motorG] = true;
	bMotorFlippedMode[motorK] = true;
	bMotorFlippedMode[motorD] = true;
	bMotorFlippedMode[motorB] = true;

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//using task for multithreading
task basketLeft(){
  //set timer to 0
  time1[T1] = 0;
  //if we are initialized
  if(initDone){
    //until we hit left sensor or 2 seconds pass spin helicopter left
    while(!leftH && time1[T1] < 2000){
      B = 100;
      updateMotors();
    }
    //stop helicopter
    B = 0;
  }
}
task basketRight(){
  //set time to 0
  time1[T2] = 0;
  //if we are initialized
  if(initDone){
    //until we hit left sensor or 2 seconds pass spin helicopter right
    while(!rightH && time1[T2] < 2000){
      B = -100;
    }
    //stop helicopter
    B = 0;
  }
}
//clear encoders
void cEnc(){
  nMotorEncoder[motorJ] = 0;
  nMotorEncoder[motorK] = 0;
}
//convineince
void openBasket(){
  StartTask(basketLeft);
}

//Autonomous Functions
//one of the tasks
task forwardToFar() {
  //if initialized
  if(initDone){
    //clear encoders
    cEnc();
    //go forward amount
    forward(6000, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    //clear encoders
    cEnc();
    if(alliance == "red"){
      //turn so that we are facing correct direction
      turnCW(8500, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }else if(alliance == "blue"){
      //turn so we are facing correct direction
      turnCCW(8500, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    //clear encoders
    cEnc();
    //forward
    forward(4000, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
  }


}
task reverseFar(){
  //if we are initialized
  if(initDone){
    //clear encoders
    cEnc();
    //reverse distance
    reverse(2049, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    //clear ecoders
    cEnc();
    if(alliance == "red"){
      //turn to right direction
      turnCCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);

    }else if(alliance == "blue"){
      //turn to right direction
      turnCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    cEnc();//clear encoders
    //go forward
    forward(6147, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    if(alliance == "red"){
      //turn to right direction
      turnCCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }else if(alliance == "blue"){
      //turn to right direction
      turnCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    cEnc(); //clear encoders
    //go forward
    forward(6147, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);

    cEnc();//clear right encoders
    if(alliance == "red"){
        //turn to end orientation
        turnCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
      }else if(alliance == "blue"){
        //turn to end orientation
        turnCCW(10000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
      }
  }
}
task forwardClose(){
  if(initDone){ //if initailzed
    cEnc(); //clear encoders
    //go forward
    forward(2049, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    cEnc();//clear encoders
    if(alliance == "red"){
      //turn to right orientation
      turnCCW(12000, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }else if(alliance == "blue"){
      //turn to right orientation
      turnCW(12000, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    cEnc();//clear encoders
    //forward distance
    forward(6147, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    cEnc();//clear encoders
    if(alliance == "red"){
      //turn to right orientation
      turnCCW(8500, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }else if(alliance == "blue"){
      //turn to right orientation
      turnCW(8500, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    cEnc();//clear encoders
    //go forward distance
    forward(4000, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);

    StartTask(basketRight); //spin helicopter to the right
  }
}
task reverseToClose(){
  if(initDone){//if initialized
    cEnc();//clear encoders
    //reverse
    reverse(2049, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    cEnc();//clear encoders
    if(alliance == "red"){
      //turn to correct orientation
      turnCW(6000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }else{
      //turn to correct orientation
      turnCCW(6000, 100, LF, LR, RF, RR,  nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    }
    cEnc();//clear encoders
    //move forward
    forward(2049, 100, LF, LR, RF, RR, nMotorEncoder[motorJ], nMotorEncoder[motorK]);
    //spin helicopter right
    StartTask(basketRight);
  }
}



task main()
{
  disableDiagnosticsDisplay();//take off their display
  eraseDisplay();//clear display
  initializeRobot();//initalize
  RFIDInit(S1);//start rfid

  while(RFIDListen){//while listening for rfid
    nxtDisplayTextLine(0, "reading");//output
    RFIDTag tag = ReadNewTag();//get tag num
    switch(tag){//do things based on tag num
      case 1:
        alliance = "red";
        nxtDisplayTextLine(0, "alliance: red");
        PlaySound(soundBeepBeep);
        wait1Msec(1000);
      break;
      case 2:
        alliance = "blue";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0, "alliance: blue");
        wait1Msec(1000);
      break;
      case 3:
        pos = "close";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0, "pos: close");
        wait1Msec(1000);
      break;
      case 4:
        pos = "far";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0,"pos: far");
        wait1Msec(1000);
      break;
      case 5:
        autoMode = "none";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0,"mode: none");
        wait1Msec(1000);
      break;
      case 6:
        RFIDListen = false;
        PlaySound(soundFastUpwardTones);
        nxtDisplayTextLine(0, "locked in");
        wait1Msec(1000);
      break;
      case 7:
        autoMode = "just F";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0,"mode: just F");
        wait1Msec(1000);
      case 8:
        autoMode = "far";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0,"mode: go for far");
        wait1Msec(1000);
      break;
      case 9:
        autoMode = "close";
        PlaySound(soundBeepBeep);
        nxtDisplayTextLine(0,"mode: go for close");
        wait1Msec(1000);
      break;
      default:
        nxtDisplayTextLine(0, "no tag");
      break;
    }
  }

  waitForStart(); // Wait for the beginning of autonomous phase.
  initDone = true; //let things happen
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
  ////                                                   ////
  ////    Add your robot specific autonomous code here.  ////
  ////                                                   ////
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////

  openBasket();//open the basket
  //different taks based on the goal for this autonomous period, the alliance, and the position
  if(autoMode == "close"){
    if(pos == "close"){
      StartTask(reverseToClose);
    }else if(pos == "far"){
      StartTask(forwardClose);
    }
  }else if(autoMode == "far"){
    if(pos == "close"){
      StartTask(reverseFar);
    }else if(pos == "far"){
      StartTask(forwardToFar);
    }
  }else if(autoMode == "just F"){
    while(true){
      RF = 100;
      RR = 100;
      LF = 100;
      LR = 100;
      updateMotors();
    }
  }else if(autoMode == "none"){
    while(true){}
  }
  while (true)
  {
    updateMotors();
    int nmask = SensorValue[S4];//get raw sensor value for touch mux
    if(nmask & 0x01){//get sensor 1 state
      touchFS = true;
    }else{
      touchFS = false;
    }
    if(nmask & 0x02){//get sensor 2 state
      leftH = true;
    }else{
      leftH = false;
    }
    if(nmask & 0x04){//get sensor 3 state
      rightH = true;
    }else{
      rightH = false;
    }
  }
}
